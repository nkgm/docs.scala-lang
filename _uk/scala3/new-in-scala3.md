---
layout: singlepage-overview
title: Нове в Scala 3
scala3: true
language: uk
---
Нова версія Scala 3 принесла багато покращень і нові можливості. 
Тут наведено короткий огляд найважливіших змін. 
Якщо ви хочете розібратись детальніше глибше, у вашому розпорядженні є наступні посилання:

- [Книга по Scala 3]({% link _overviews/scala3-book/introduction.md %}) націлений на розробників-початківців мови Scala.
- [Конспект синтаксису][syntax-summary] надає формальний опис нового синтаксису.
- [Довідник з мови][reference] дає детальний опис змін від Scala 2 до Scala 3.
- [Посібник з міграції][migration] надає вам всю інформацію, необхідну для переходу від Scala 2 до Scala 3.
- [Посібник для внесення змін в Scala 3][contribution] глибше занурюється в компілятор, включаючи посібник із розв'язання проблем.

## Що нового в Scala 3
Scala 3 - це повне перероблення мови Scala. Було змінено багато аспектів
системи типів на більш принципові. Хоч це і надає нові можливості (наприклад, об’єднання типів), 
але в першу чергу це означає, що у вашій роботі стає менше системи типів та [наведення типів][type-inference].
Також значно покращено процес перевантаження.

### Нове і яскраве: Синтаксис
Окрім багатьох (невеликих) очищень, синтаксис Scala 3 пропонує такі покращення:

- Новий «тихий» синтаксис для керуючих структур, таких як `if`, `while` та `for` ([новий синтаксис керуючих структур][syntax-control])
- Ключеве слово `new` тепер опціональне (_або_ [creator applications][creator])
- [Опціональні дужки][syntax-indentation] привертають до стилю програмування на основі відступів
- Зміна [символу підстановки типів][syntax-wildcard] з `_` на `?`.
- Імплісіти (та їх синтаксис) були [ґрунтовно переглянуті][implicits].

### Впертість: контекстні абстракції
Одним з основних концептів Scala було (і залишається певною мірою)
надання користувачам невеликого набору потужних можливостей, які можна комбінувати
заради великої (а іноді навіть непередбачуваної) виразності. Наприклад, _implicits_
використовувалися для моделювання контекстної абстракції, для вираження обчислення
на рівні типів, моделювання типів-класів, виконання неявних приведень, кодування
розширення методів та багато іншого.
Базуючись на цих прикладах використання, Scala 3 використовує дещо інший підхід
і фокусується на **намірі**, а не на **механізмі**.
Замість того, щоб пропонувати одну дуже потужну функцію, Scala 3 пропонує кілька
спеціальних мовних конструкцій, що дозволяють програмістам прямо висловлювати свої наміри:

- **Абстрагування над контекстною інформацією**. [Ключове слово using][contextual-using] дозволяє програмістам абстрагуватися від інформації, яка доступна в контексті виклику і повинна передаватися неявно. Конструкція using є удосконаленням implicit зі Scala 2 та може бути визначена за типом, звільняючи сигнатури функцій від термів, на які ніколи не посилаються явно.

- **Надання екземплярів класів типів**. [Наведені екземпляри][contextual-givens] дозволяють програмістам визначати _канонічне значення_ певного типу. Це робить програмування з класами типів простішим без витоку деталей реалізації.

- **Ретроспективне розширення класів**. У Scala 2 методи розширення повинні бути закодовані за допомогою неявних перетворень або неявних класів. На відміну від цього, у Scala 3 [методи розширення][contextual-extension] тепер безпосередньо вбудовані в мову, що призводить до кращих повідомлень про помилки та покращеного виведення типу.

- **Відображення одного типу як іншого**. Неявні перетворення були [перероблені][contextual-conversions] з нуля як екземпляри класу типів `Conversion`.

- **Контекстні абстракції вищого порядку**. _Абсолютно нова_ можливість [контекстних функцій][contextual-functions] робить контекстні абстракції first-class citizen. Вони є важливим інструментом для авторів бібліотек і дозволяють стисло виразити домен-специфічні мови.

- **Дієвий відгук від компілятора**. Якщо неявний параметр не може бути розв'язаний компілятором, то надаються [пропозиції імпорту](https://www.scala-lang.org/blog/2020/05/05/scala-3-import-suggestions.html), що можуть розв'язувати проблему.

### Скажи що маєш на увазі: покращення системи типів
Окрім значно покращеного виведення типів, система типів Scala 3 також пропонує багато нових функцій, надаючи вам потужні інструменти для статичного вираження інваріантів у типах:

- **Перерахування**. [Enum][enums] був перероблений, щоб добре поєднуватися з кейс-класами та сформувати новий стандарт для вираження [алгебраїчних типів даних][enums-adts].

- **Непрозорі типи**. Сховайте деталі реалізації за [псевдонімом непрозорого типу][types-opaque] без зниження перфомансу! Непрозорі типи замінюють класи значень і дозволяють налаштувати бар'єр абстракції без додаткових накладних витрат.

- **Типи перетину та об'єднання**. Нові засади системи типів призвели до введення нових можливостей системи типів: екземпляр [типу Intersection][types-intersection], як `A & B`, є екземпляром _обох_ типів і `A` і `B`. Екземпляр [типу Union][types-union], як `A | B`, є екземпляром _або_ `A` або `B`. Обидві конструкції дозволяють програмістам гнучко обмежувати типи поза межами ієрархії наслідування.

- **Залежні типи функцій**. Scala 2 вже дозволяє типам результату залежати від (значення) аргументів. У Scala 3 тепер можна абстрагуватися над цим шаблоном і виразити [залежні типи функцій][types-dependent]. В типі `type F = (e: Entry) => e.Key` результат _залежить_ від аргументу!

- **Поліморфні типи функцій**. Як і типи функцій залежності, Scala 2 підтримувала методи, які дозволяють параметри типу, але не дозволяла абстрагуватися над цими методами. У Scala 3, [поліморфні типи функцій][types-polymorphic], наприклад `[A] => List[A] => List[A]` абстрагується над функцією, що приймає _аргумент типу_ на додачу до аргументів значень.

- **Лямбда типу**. Те, що виражалося з використанням [плагіна компілятора](https://github.com/typelevel/kind-projector) в Scala 2 тепер є першокласною особливістю в Scala 3: Лямбда типу — це функції рівня типів, які можна передавати як аргументи типу (вищого роду) без визначення допоміжного типу.

- **Відповідність типів**. Замість того, щоб кодувати обчислення на рівні типу з використанням імплісітів, Scala 3 пропонує пряму підтримку [відповідності за типами][types-match]. Інтеграція обчислень на рівні типів у процес перевірки типів дозволяє покращити повідомлення про помилки та усуває необхідність у складному кодуванні.


### Переосмислено: об'єктно-орієнтоване програмування
Scala завжди була на межі між функціональним програмуванням та об'єктноорієнтованим програмуванням -- і Scala 3 розширює межі в обох напрямках!
Вищезгадані зміни в системі типів і перероблення контекстних абстракцій роблять _функціональне програмування_ легшим, ніж раніше.
Водночас наступні нові функції дозволяють добре структурувати _об'єктноорієнтовані проєкти_ та підтримують найкращі практики.

- **Pass it on**. Трейти наближаються до класів і тепер також можуть приймати [параметри][oo-trait-parameters], що робить їх ще більш потужними як інструмент для модульної декомпозиції.
- **План розширення**. Класи розширення, які не призначені для наслідування, є давньою проблемою в об'єктноорієнтованому програмуванні. Для розв'язання цього питання, [відкриті класи][oo-open] вимагають у розробників бібліотек _явно_ позначити класи як відкриті.
- **Приховати деталі реалізації**. Утилітні трейти, які іноді реалізують поведінку, не повинні входити до складу виведених типів. У Scala 3, такі трейти можуть бути позначені як [прозорі][oo-transparent] приховуючи наслідування від користувача (у виведених типах).
- **Композиція понад спадковістю**. Це поняття широко згадується, але є важким у реалізації. Але не з [export][oo-export] у Scala 3's: симетричні до імпорту, експорти дозволяють користувачеві визначати псевдоніми для вибраних членів об'єкта.
- **Більше без NPE**. Scala 3 безпечніша, ніж будь-коли: [явний null][oo-explicit-null] виводить `null` з ієрархії типів, допомагаючи статично виловлювати помилки; додаткові перевірки для [безпечної ініціалізації][oo-safe-init] виявляють доступ до неініціалізованих об'єктів.


### Батарейки в комплекті: метапрограмування
Хоча макроси в Scala 2 були лише експериментальною функцією, Scala 3 поставляється з потужним арсеналом інструментів для метапрограмування.
[Посібник по макросах]({% link _overviews/scala3-macros/tutorial/index.md %}) містить детальну інформацію про різні об'єкти. Зокрема, Scala 3 пропонує наступні можливості для метапрограмування:

- **Inline**. Як відправна точка, [inline][meta-inline] дозволяє редукувати значення та методи під час компіляції. Ця проста функція вже охоплює багато варіантів використання і в той же час є точкою входу для більш розширених функцій.
- **Операції під час компіляції**. Пакет [`scala.compiletime`][meta-compiletime] містить додаткову функціональність, яку можна використовувати для реалізації вбудованих методів.
- **Цитування блоків коду**. Scala 3 додає нову можливість [квазі-цитування][meta-quotes] коду, що надає зручний інтерфейс високого рівня для побудови та аналізу коду. Побудувати код для додавання одиниці до одиниці так само просто, як і `'{ 1 + 1 }`.
- **API рефлексії**. Для більш просунутих випадків використання [quotes.reflect][meta-reflection] забезпечує більш детальний контроль для перевірки та створення дерев програм.

Якщо ви хочете дізнатися більше про метапрограмування в Scala 3, пропонуємо подивитись на наш [посібник][meta-tutorial].


[enums]: {{ site.scala3ref }}/enums/enums.html
[enums-adts]: {{ site.scala3ref }}/enums/adts.html

[types-intersection]: {{ site.scala3ref }}/new-types/intersection-types.html
[types-union]: {{ site.scala3ref }}/new-types/union-types.html
[types-dependent]: {{ site.scala3ref }}/new-types/dependent-function-types.html
[types-lambdas]: {{ site.scala3ref }}/new-types/type-lambdas.html
[types-polymorphic]: {{ site.scala3ref }}/new-types/polymorphic-function-types.html
[types-match]: {{ site.scala3ref }}/new-types/match-types.html
[types-opaque]: {{ site.scala3ref }}/other-new-features/opaques.html

[type-inference]: {{ site.scala3ref }}/changed-features/type-inference.html
[overload-resolution]: {{ site.scala3ref }}/changed-features/overload-resolution.html
[reference]: {{ site.scala3ref }}/overview.html
[creator]: {{ site.scala3ref }}/other-new-features/creator-applications.html
[migration]: {% link _overviews/scala3-migration/compatibility-intro.md %}
[contribution]: {% link _overviews/scala3-contribution/contribution-intro.md %}

[implicits]: {{ site.scala3ref }}/contextual
[contextual-using]: {{ site.scala3ref }}/contextual/using-clauses.html
[contextual-givens]: {{ site.scala3ref }}/contextual/givens.html
[contextual-extension]: {{ site.scala3ref }}/contextual/extension-methods.html
[contextual-conversions]: {{ site.scala3ref }}/contextual/conversions.html
[contextual-functions]: {{ site.scala3ref }}/contextual/context-functions.html

[syntax-summary]: {{ site.scala3ref }}/syntax.html
[syntax-control]: {{ site.scala3ref }}/other-new-features/control-syntax.html
[syntax-indentation]: {{ site.scala3ref }}/other-new-features/indentation.html
[syntax-wildcard]: {{ site.scala3ref }}/changed-features/wildcards.html

[meta-tutorial]: {% link _overviews/scala3-macros/tutorial/index.md %}
[meta-inline]: {% link _overviews/scala3-macros/tutorial/inline.md %}
[meta-compiletime]: {% link _overviews/scala3-macros/tutorial/compiletime.md %}
[meta-quotes]: {% link _overviews/scala3-macros/tutorial/quotes.md %}
[meta-reflection]: {% link _overviews/scala3-macros/tutorial/reflection.md %}

[oo-explicit-null]: {{ site.scala3ref }}/experimental/explicit-nulls.html
[oo-safe-init]: {{ site.scala3ref }}/other-new-features/safe-initialization.html
[oo-trait-parameters]: {{ site.scala3ref }}/other-new-features/trait-parameters.html
[oo-open]: {{ site.scala3ref }}/other-new-features/open-classes.html
[oo-transparent]: {{ site.scala3ref }}/other-new-features/transparent-traits.html
[oo-export]: {{ site.scala3ref }}/other-new-features/export.html
